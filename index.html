<!DOCTYPE HTML>
<body>
	<canvas id="canvas" width = "500" height = "500"></canvas>
</body>

<script>
	function BETTERCANVAS(canvasID){
		this.canvas = document.getElementById(canvasID);
		this.ctx = this.canvas.getContext("2d");
		this.width = this.canvas.width;
		this.height = this.canvas.height;
		this.size = this.width * this.height;
		this.pointList = new Uint8ClampedArray(this.size * 4);
		this.secondLayer = new Uint8ClampedArray(this.size * 4);
		this.radius = 30;
		this.drawnTemp = {};
		this.prof = 0;
		this.gradient = {};
	}
	BETTERCANVAS.prototype = {
		addBall: function(x0, y0){
            var orad = this.radius;
            var increment = this.map_range(1, 0, orad,0,255);
            var x = this.radius;
            var y = 0;
            var radiusError = 1 - x;
            while (x >= y){
                this.horizontalLine(-x + x0, y + y0, x + x0, y + y0, x0,y0);
                this.horizontalLine(-y + x0, -x + y0, y + x0, -x + y0, x0,y0);
                this.horizontalLine(-x + x0, -y + y0, x + x0, -y + y0, x0,y0);
                this.horizontalLine(-y + x0, x + y0, y + x0, x + y0, x0,y0);
                y++;
                if (radiusError<0){
                    radiusError += 2 * y + 1;
                }
                else{
                    x--;
                    radiusError += 2 * (y - x) + 1;
                }
            }
            this.drawnTemp = {};
		},
		addPoint: function(x, y, alpha){
			this.pointList[this.getRIndexPos(x, y) + 3] = this.pointList[this.getRIndexPos(x, y) + 3]+alpha, 255;
		},
		horizontalLine: function(xi, yi, xf, yf, x0, y0){
			function lineDistance(x,y){
			  var xs = Math.pow(x - x0, 2);
			  var ys = Math.pow(y - y0, 2);
			  return Math.sqrt( xs + ys );
			}
			// Assumes xi is on the left and xf is on the right
			var xPointer = xi;
			while (xPointer <= xf){
				if(typeof this.drawnTemp[xPointer+":"+yi] === "undefined"){
					var alpha = Math.round(this.map_range(lineDistance(xPointer, yi), 0, this.radius, 30, 0));
					this.addPoint(xPointer, yi, alpha);
					this.drawnTemp[xPointer+":"+yi]=true;
				}
				xPointer ++;
			}
		},
		contour: function(granularity){
			var step = 255/granularity;
			var i = 0, a = new Uint8ClampedArray(granularity+1), c=0;
			while (i<255){
				a[c] = i;
				i += step;
				c++;
			}
			a[a.length-1] = 255;
			var l = -step/2;
			for(var i = 0; i<a.length; i++){
				var thisAlpha = a[i]/255;
				this.ctx.fillStyle = "rgba(0, 0, 0, " + thisAlpha + ")";
				this.ctx.fillRect(0, l, 1, step);
				l+=step;
			}
			var _grad = this.ctx.getImageData(0, 0, 1, 255).data;
			this.ctx.clearRect(0, 0, 1, 256);
			
			for (var i = 0; i< this.pointList.length; i+=4){
				var currentAlpha = this.pointList[i+3];
				this.pointList[i+3] = this.pointList[i+3] === 255? 255: _grad[currentAlpha*4+3];
			}
			this.draw();
		},
		draw: function(){
			// this.contour();
			if(!this.imageData) this.imageData = this.ctx.createImageData(this.width, this.height);
		    this.imageData.data.set(this.pointList);
		    this.ctx.putImageData(this.imageData, 0, 0);
		},
		invalidate: function(){
			if(!this.imageData) this.imageData = this.ctx.createImageData(this.width, this.height);
			this.pointList = new Uint8ClampedArray(this.size * 4);
		    this.imageData.data.set(this.pointList);
		    this.ctx.putImageData(this.imageData, 0, 0);
		},
		getRIndexPos: function(x,y){
			var rIndexPos = (y*this.width+x)*4;
			return rIndexPos;
		},
		map_range: function(value, low1, high1, low2, high2) {
            return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
        }
	};
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	var b = new BETTERCANVAS("canvas");
	b.radius = 30;
	var interval;
	var md = false
	document.onmousedown = function(e){
		md = true;
		b.invalidate();
	};
	document.onmousemove = function(e){
		if(md){
			b.addBall(e.x, e.y); 
			b.draw();
		}
	}
	document.onmouseup = function(e){
		md = false
		b.contour(10);
	};
	
	

</script>